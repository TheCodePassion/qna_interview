-- https://dou.ua/lenta/articles/interview-node-js/?from=comment-digest_post&utm_source=digest-comments&utm_medium=email&utm_campaign=31072023
ðŸ’¡ Junior
Node.js

1. What is Node.js?
Node.js is an open-source, server-side JavaScript runtime environment that allows developers to execute JavaScript code outside of a web browser. 

2. What are the main advantages and disadvantages of using Node.js?
- Advantages of using Node.js:
Speed and efficiency: Node.js is built on the V8 JavaScript engine, which provides high performance and executes code quickly, leading to faster application development and improved server response times.
Non-blocking, event-driven architecture: Node.js uses an event loop that allows asynchronous I/O operations, making it efficient in handling concurrent connections and scalable for real-time applications.
Single language throughout the stack: JavaScript can be used both on the client-side and server-side, allowing developers to work with the same language and share code between the front-end and back-end, 
reducing the need for context switching.
Large and active community: Node.js has a vast and active community of developers, which means extensive support, numerous libraries, and frequent updates, making it easier to find solutions 
to problems and access a wide range of modules.
Package manager (npm): Node.js comes with npm (Node Package Manager), a powerful tool that enables easy installation, management, and sharing of packages and modules, enhancing code reusability.
- Disadvantages of using Node.js:
Not suitable for CPU-intensive tasks: Node.js is designed to excel in I/O-intensive applications, but it may not be the best choice for CPU-intensive tasks due to its single-threaded nature.
Callback-heavy code: Asynchronous programming in Node.js relies on callbacks, which can lead to complex and nested code structures (known as "callback hell") if not managed properly.
Immaturity in some areas: While Node.js has grown rapidly, certain areas of the ecosystem may still be less mature or lack adequate documentation and community support.
Lack of multi-core utilization by default: Node.js runs on a single thread, which means it doesn't natively utilize multiple CPU cores. Developers need to implement additional strategies (e.g., clustering) 
to leverage multi-core systems effectively.
Security concerns: Being open-source and widely used, Node.js may become a target for security vulnerabilities. Careful attention should be given to keep dependencies updated and adopt security best practices.

3. For which tasks is Node.js not suitable?
There are certain tasks for which Node.js might not be the most suitable choice:
- CPU-Intensive Tasks: Node.js is built on the V8 JavaScript engine, which is excellent for handling I/O operations and asynchronous tasks but not well-suited for CPU-intensive computations. 
If your application requires heavy computational tasks, such as complex data processing, image manipulation, or video encoding, using Node.js might not be the most efficient option. 
In such cases, a language like Python, Go, or C++ might be more suitable.
- Memory-Intensive Applications: While Node.js performs well with many concurrent connections, it may not be the best choice for applications that require a significant amount of memory.
If your application involves heavy in-memory data processing or caching large datasets, other languages like Java or C++ with more memory management control might be more appropriate.
- High-Throughput Synchronous Operations: Node.js is inherently single-threaded, and synchronous operations can block the event loop, leading to performance bottlenecks. 
In scenarios where an application heavily relies on synchronous I/O operations, other languages like Go or Java with multithreading or asynchronous capabilities may be more suitable.
- Real-Time Data Manipulation: Node.js is excellent at handling real-time web applications using technologies like WebSockets. However, for applications that require low-level data manipulation or hardware interaction, 
languages like C or C++ might be more suitable due to their performance and direct access to hardware.
- Complex Multi-Threaded Applications: Node.js, being single-threaded, might not be the best choice for developing complex multi-threaded applications that require extensive parallelism
and low-level control over threads. In such cases, languages like Java or Go, with strong support for multi-threading, are better options.
- Enterprise-level ETL (Extract, Transform, Load) Processes: While Node.js can handle ETL processes for smaller projects, for large-scale, complex enterprise-level 
ETL tasks that involve significant data processing and transformation, specialized ETL tools like Apache Spark or Apache NiFi might be more appropriate.
- Resource-Intensive Background Jobs: For resource-intensive, long-running background jobs, using a task-specific tool or language like Celery (Python), Sidekiq (Ruby), or Apache Kafka might be more suitable.
In conclusion, Node.js might not be the best choice for tasks that are CPU-intensive, memory-intensive, require high-throughput synchronous operations, involve complex multi-threading, or necessitate low-level hardware interactions.

4. What are the main components of Node.js?
- V8 Engine: Node.js is built on the Google V8 JavaScript engine, which is also used in the Chrome web browser. V8 compiles JavaScript code into machine code, making it much faster than traditional interpreters.
- Libuv: Libuv is a multi-platform, asynchronous I/O (Input/Output) library that provides the foundation for Node.js' non-blocking, event-driven architecture. It handles tasks like networking, file system operations, and timers.
- Core Modules. NPM 
- Event Loop: Node.js follows an event-driven, non-blocking I/O model, and the event loop is at the core of this approach. 
It continuously checks for pending events and executes their corresponding callbacks, making Node.js highly efficient and scalable for handling concurrent connections.


5. How does Node.js server handle multiple concurrent client requests with only one thread?
- Event Loop:
Node.js relies on an event loop to manage its asynchronous operations. The event loop is a single thread that continuously checks for pending events, executes callbacks, and delegates I/O operations to the system's underlying kernel asynchronously.
- Non-Blocking I/O:
When Node.js performs I/O operations, such as reading from a file, making an HTTP request, or querying a database, it does so in a non-blocking manner. Instead of waiting for the operation to complete, Node.js immediately moves on to execute other code, allowing it to handle other client requests while waiting for the I/O operation to finish.
- Callbacks and Event-Driven Programming:
Node.js uses callbacks to handle the results of asynchronous operations. When an asynchronous operation completes, it triggers a callback function, which is then executed by the event loop. This allows Node.js to process multiple client requests simultaneously without blocking the execution of other code.
- Single Thread, Multi-Threaded I/O:
While the JavaScript code in Node.js is executed in a single thread, the underlying I/O operations are handled by the operating system's multi-threaded I/O capabilities. Node.js leverages this by delegating I/O tasks to the operating system's kernel and handling the responses asynchronously when they are ready.
- Concurrency through Event Loop:
Since Node.js can handle many I/O operations simultaneously, it can efficiently manage multiple concurrent client requests. As each request's I/O operation is delegated to the event loop, Node.js can move on to process other requests without waiting for the I/O to complete.
- Avoiding CPU-Intensive Tasks:
While Node.js excels at handling I/O-bound tasks and concurrent client requests, it is not well-suited for CPU-intensive tasks that consume the event loop for extended periods. In such cases, the event loop may become blocked, and other client requests may be delayed. To handle CPU-bound tasks efficiently, developers often use techniques like offloading the processing to worker threads or using external services.


6. Is it possible to use multiple threads in Node.js? Which modules are used for this purpose?
Yes, it is possible to use multiple threads in Node.js to perform CPU-intensive tasks more efficiently and avoid blocking the event loop. Node.js provides support for creating and managing multiple threads through the "Worker Threads" module, which was introduced in Node.js version 10.5.0 and is stable from version 12 onward.
The "Worker Threads" module allows you to create and communicate with additional threads that run in parallel to the main Node.js process. These worker threads can execute CPU-intensive tasks independently, freeing up the main thread to continue processing other tasks, such as handling incoming client requests.

7. Does Node.js interpret or compile program code?
Node.js uses a combination of interpretation and compilation to execute program code.
Interpretation:
Node.js is an interpreter for JavaScript code. When you run a Node.js application, the JavaScript code is read line by line, and the Node.js runtime interprets each line of code and executes it immediately. This interpretation happens at runtime, which means the code is executed on-the-fly without any pre-processing.
Just-in-Time (JIT) Compilation:
Node.js also employs Just-in-Time (JIT) compilation to optimize the performance of JavaScript execution. As the code is being interpreted and executed, the Node.js engine analyzes the code and identifies hotspotsâ€”sections of code that are executed frequently. It then compiles those hotspots into optimized machine code.
- So, the flow of execution in a Node.js application generally involves the following steps:
The Node.js runtime interprets the JavaScript code line by line.
As hotspots are identified, the V8 engine performs JIT compilation to convert those sections into optimized machine code.
The optimized machine code is executed, resulting in faster performance for frequently executed parts of the code.

8. How to read large files using Node.js?
To handle large files, you should use asynchronous methods and read the file in smaller chunks rather than loading the entire file into memory.
- Choose the Asynchronous Approach:
Using asynchronous file operations is crucial for handling large files. Asynchronous methods ensure that your Node.js application doesn't block while reading the file and can continue processing other tasks.
- Use Streams:
Node.js provides built-in support for streams, which are a mechanism for reading and writing data in chunks. Streams are particularly useful for handling large files as they read data incrementally without loading the entire file into memory.
- Create a Readable Stream:
To read a file using streams, you need to create a readable stream. You can use the fs.createReadStream() method to achieve this. The createReadStream() method allows you to specify the file path and options such as encoding, highWaterMark (the size of each chunk), etc.
- Handle Stream Events:
Once you have a readable stream, you can listen for specific events to handle the data. The essential events to handle are data, which is triggered when new data chunks are available, and end, which is triggered when the entire file has been read.
- Process Data in Chunks:
As the data event is triggered, you'll receive chunks of data. Process the data as needed in each event callback to avoid loading the entire file into memory at once.

9. What are libuv and v8? What are their purposes?
libuv:
libuv is a cross-platform, asynchronous I/O library that provides the event loop, which is the foundation for Node.js' non-blocking, event-driven architecture. It abstracts the operating system's underlying I/O capabilities and provides a consistent API for handling events, timers, network operations, and file system operations.
Purposes of libuv - Event Loop, Asynchronous I/O, Cross-Platform Support, Timers and Event Handling
V8:
V8 is an open-source JavaScript engine developed by Google. It is written in C++ and is the heart of Google Chrome's JavaScript execution. Node.js leverages V8 as its JavaScript runtime, allowing it to execute JavaScript code efficiently and with high performance.
Purposes of V8: JavaScript Execution, Memory Management, Cross-Platform Support, ECMAScript Compliance

10. What is the difference between microtasks and macrotasks? Provide examples of such tasks.
Microtasks and macrotasks are two types of tasks that are managed by the event loop in JavaScript environments, including Node.js and web browsers.
Microtasks are tasks with higher priority than macrotasks. Microtasks are tasks with higher priority than macrotasks. Microtasks are tasks with higher priority than macrotasks. 
When the event loop checks for pending tasks, it first processes all microtasks before moving on to macrotasks. Microtasks are typically used for tasks that need to be executed immediately after the current script finishes, but before the next rendering or I/O event. They allow developers to control the order of execution more precisely.
Promise callbacks. process.nextTick(). Mutation Observer
Macrotasks, also known as "tasks" or "callbacks," have lower priority than microtasks. They are added to the macrotask queue, and the event loop processes them after all pending microtasks have been executed. Macrotasks are usually I/O-bound or timer-based operations.
I/O operations: Reading from or writing to files or sockets.
Timers: setTimeout, setInterval, and setImmediate.
Network requests: Fetching data from a remote server using HTTP requests.
DOM rendering: Handling updates to the DOM and user interface.
The order of execution for tasks in the event loop is as follows:
Execute all pending microtasks (Process all microtasks in the microtask queue).
Execute one macrotask (Dequeue and execute a task from the macrotask queue).
If there are more microtasks, go back to step 1. Otherwise, continue to the next macrotask (if any).

11. What is a stream?
A stream is a fundamental concept in Node.js used for handling data efficiently, especially when dealing with large amounts of data or data that arrives or needs to be processed incrementally. Streams provide an abstraction to read or write data in chunks, allowing for lower memory usage and faster processing, as data is processed as soon as it becomes available, instead of waiting for the entire data set to be loaded.

12. What types of streams do you know?
Readable Stream:
A readable stream represents a source of data from which you can read data chunk by chunk. Examples of readable streams include reading from files, making HTTP requests, and processing incoming network connections. Readable streams emit events like 'data', 'end', and 'error' to handle the data as it arrives or encounters an error.
Writable Stream:
A writable stream represents a destination where you can write data chunk by chunk. Examples of writable streams include writing to files or making HTTP responses. Writable streams can be used to handle incoming data and store it or send it to another location.
Streams can also be Transform Streams, which are both readable and writable.

13. What is the event loop? What are its components, and how does it work?
The event loop is a crucial part of Node.js (and other JavaScript environments) that enables non-blocking, asynchronous behavior, making it efficient for handling I/O-bound operations and concurrent tasks. 
The event loop is responsible for managing the execution of callbacks and events in a continuous loop, ensuring that code runs efficiently without blocking the main thread.
Components of the Event Loop:
Call Stack:
The call stack is a stack data structure that keeps track of function calls in the current execution context. When a function is called, it is pushed onto the stack, and when the function returns, it is popped off the stack. The call stack handles the synchronous execution of code.
Callback Queue (Task Queue):
The callback queue is a queue that stores asynchronous callbacks, such as those from I/O operations (e.g., reading from a file, making an HTTP request) or timers (e.g., setTimeout, setInterval). When an asynchronous operation is completed, its callback is placed in the callback queue.
Microtask Queue (Job Queue):
The microtask queue is another queue that stores microtasks. Microtasks are used to handle higher-priority tasks that need to be executed immediately after the current operation but before the event loop continues to process other callbacks. Microtasks are typically used for Promise callbacks and other high-priority tasks.
How the Event Loop Works:
The event loop runs continuously, checking for tasks in the following order:
Check for Microtasks:
Before executing any macrotask (e.g., I/O callback, timer callback), the event loop checks if there are any pending microtasks in the microtask queue. If there are, it executes all microtasks in sequence until the microtask queue is empty.
Execute Macrotasks (Callback Queue):
If there are no microtasks or after all microtasks have been executed, the event loop dequeues and executes one macrotask (callback) from the callback queue. This task can be an I/O operation completion callback or a timer callback, among others.
Perform Rendering (Optional, in the Browser):
In web browsers, the event loop might include a rendering step, where the browser renders changes to the DOM. This step is omitted in Node.js, which does not handle rendering.
Repeat:
After executing a macrotask, the event loop starts again by checking for microtasks, executing macrotasks, and so on, in a continuous loop.

14. What is logging and monitoring?
Logging is the process of recording information about events, actions, and errors that occur within your Node.js application. Logs are essential for debugging and troubleshooting issues in production environments. Commonly, logs are written to files or sent to centralized logging services, where they can be easily analyzed.
Monitoring involves the continuous observation of various metrics and performance indicators of your Node.js application during runtime. It helps identify potential bottlenecks, performance issues, and anomalies that may arise in the system. Monitoring allows you to maintain the health and stability of your application by keeping track of various aspects, including:

15. What is the difference between a monolith and a microservice?
A monolith and a microservice are two different architectural styles used in software development to design and build applications.
A monolithic architecture refers to an application that is built as a single, large, and interconnected unit. In a monolith, all components, modules, and functionalities of the application are tightly coupled and run as a single process. This means that the entire application is deployed as one unit, and any changes or updates to a specific part of the application require redeploying the entire monolith.
Advantages of Monolith:
Simplicity: Developing and deploying a monolith can be simpler and easier compared to a microservices architecture.
Performance: Monoliths can be more efficient in terms of resource usage because there is less overhead in communication between components.
Disadvantages of Monolith:
Scalability: It can be challenging to scale different components independently in a monolith, limiting the ability to handle high loads.
Maintenance: As the application grows, maintaining and evolving a monolith can become complex and challenging.
Continuous Deployment: Making frequent updates to a monolithic application can lead to downtimes during the deployment process.
Microservices:
Microservices, on the other hand, is an architectural style where an application is divided into a set of loosely coupled and independently deployable services. Each service represents a specific business capability and can be developed, deployed, and scaled independently. These services communicate with each other through APIs, allowing them to work together as part of a larger system.
Advantages of Microservices:
Scalability: Microservices allow you to scale specific services independently, making it easier to handle varying loads on different parts of the application.
Flexibility: Since each microservice is a separate unit, developers can use different technologies, programming languages, and databases that suit the specific requirements of each service.
Continuous Deployment: Microservices promote continuous deployment practices, enabling faster updates and reducing the risk of downtime during updates.
Disadvantages of Microservices:
Complexity: The distributed nature of microservices adds complexity to the system, which can lead to challenges in monitoring, testing, and debugging.
Overhead: Communication between microservices can introduce additional overhead compared to the more streamlined communication in monoliths.
Development Effort: Building and managing microservices requires additional effort in terms of design, deployment, and coordination.

16. What is the difference between language keywords like 'string' and 'String'?
'string':
In JavaScript, 'string' is not a keyword; it is a primitive data type.
'String':
In JavaScript, 'String' is a built-in constructor function for strings. Unlike the 'string' data type, 'String' is an object wrapper for strings. You can use 'String' to create instances of string objects. For example:
javascript
const myStringObj = new String("Hello, world!");



Express.js

17. What is the purpose of using middleware?
Middleware in Express is a fundamental concept that allows you to add modular functionalities and processing steps to your web application's request-response cycle. It acts as a bridge between the incoming HTTP request and the final HTTP response, allowing you to perform various tasks, modifications, or validations before the request reaches its final destination (route handler) or after the response has been generated.

18. How to transition from one middleware to another?
In Express, middleware functions are executed in the order they are defined in the code. When you call the next() function inside a middleware, it passes control to the next middleware function in the chain. This allows you to transition from one middleware to another.

19. How to prioritize middleware?
In Express, the order in which you define middleware determines their priority. Middleware functions are executed in the order they are added using the app.use() or router.use() methods. The earlier a middleware is defined, the higher its priority.

20. How to organize an error handler?
Organizing an error handler in Express involves creating a dedicated middleware function to handle errors that occur during the request-response cycle. This helps you centralize error handling logic and provide consistent error responses to clients. 
1. Create the Error Handler Middleware
2. Error Response Structure
3. Throwing Errors
4. Async Error Handling 

JavaScript

21. What is asynchronous behavior and asynchronous code?
In JavaScript, asynchronous behavior refers to the ability of the language to execute code in a non-blocking manner. Asynchronous code allows you to perform tasks without waiting for previous tasks to complete, which is particularly important for handling operations that might take some time to finish, such as network requests, file I/O, or other time-consuming operations.

22. What is the difference between var, let, and const? Why should const be used if the variable will not be changed later in the code?
In JavaScript, var, let, and const are used to declare variables, but they have different scopes and behaviors. Here's a breakdown of the differences:
- var: Variables declared with var are function-scoped or globally-scoped, depending on whether they are declared inside a function or outside of any function. They are also hoisted to the top of their scope, which means they are moved to the top of their containing function or script before execution.
- let: Variables declared with let are block-scoped, which means they are confined to the block (enclosed by curly braces) in which they are declared. They are not hoisted to the top of the block and are not accessible before the declaration.
- const: Like let, variables declared with const are block-scoped and not hoisted. The key difference is that variables declared with const must be assigned a value when declared, and once assigned, their value cannot be changed. They are constants.
In summary, use var when you need function or global scope (although let and const are generally preferable), use let when you need block scope and intend to reassign the variable, and use const when you need block scope and want to ensure the variable's value remains unchanged.

23. How can you delay the execution of a function to a specific time?
In JavaScript, you can delay the execution of a function to a specific time using two main methods: setTimeout and setInterval

24. How can you delay the execution of a function to a specific time?
To delay the execution of a function to a specific time, you can use the setTimeout function in JavaScript. setTimeout allows you to schedule the execution of a function after a certain delay in milliseconds.

25. What methods of declaring a function do you know?
Function Declaration. Function Expression. Arrow Function Expression. Method Shorthand. Function Constructor. Immediately Invoked Function Expression. Async Function Declaration

26. What is an anonymous function?
An anonymous function is a function that does not have a name. In programming, functions are typically defined with a name that can be used to call or reference the function later. However, in some cases, you might want to create a function without giving it a name. Such functions are called "anonymous functions."

27. Provide examples of self-invoking functions.
(function() {
  console.log("This is a self-invoking function!");
})();

28. What is the difference between function expression and function declaration?
Hoisting:
Function Declarations are hoisted in JavaScript, which means they are moved to the top of their containing scope during the compilation phase. This allows you to call a function before its actual declaration in the code.
Function Expressions, on the other hand, are not hoisted in the same way. The variable containing the function is hoisted, but the assignment of the function to the variable remains where it is in the code.
Syntax

29. How can you create a new array in JavaScript containing only numbers greater than 10 from an existing array of numbers? Which array method would you use for this?
const existingArray = [5, 12, 8, 15, 20, 3, 18];
const newArray = existingArray.filter(number => number > 10);

30. How can you delete an element from an array and an object?
Deleting an Element from an Array:
Using splice() method. Using filter() method (creates a new array without the element). 
Deleting a Property from an Object delete myObject[keyToDelete];

31. What is the purpose of the void type?
In JavaScript, the void keyword is used to evaluate an expression and then return the undefined value. It doesn't serve a particularly functional purpose in the sense of producing a useful value, but it can be used in a couple of scenarios:

32. Where and why do you use super()?
In object-oriented programming languages like JavaScript, the super() keyword is used to call the constructor of a parent class. It is used within the constructor of a subclass to invoke the constructor of its parent class. This is typically done when you want to initialize properties or perform setup logic that is common to both the subclass and the parent class.

33. What is the purpose of 'this' keyword and in what scenarios is it used?
The this keyword in JavaScript is a special keyword that refers to the current context or object. Its behavior can change depending on how and where it is used. The primary purpose of the this keyword is to refer to the object that the currently executing code belongs to. 

34. What is NaN and how can you use it?
NaN stands for "Not-a-Number," and it is a special value in JavaScript used to represent the result of an invalid or undefined mathematical operation. In other words, when a mathematical operation or function is expected to return a number, but it fails to do so, the result is NaN.

35. What is NPM? What alternatives do you know?
NPM (Node Package Manager) is a package manager for JavaScript programming language. It is primarily used for managing and distributing packages (libraries, modules, and tools) that you can use to build JavaScript applications, both on the frontend and the backend. NPM is tightly integrated with Node.js, a runtime environment that allows you to execute JavaScript code outside of a web browser.
Yarn. pnpm. Bower

36. What are the advantages and disadvantages of NPM compared to Yarn/PNPM?
NPM (Node Package Manager):
Advantages:
Comes bundled with Node.js, so no additional installation is needed.
Large and mature package registry with a wide selection of packages.
Well-documented and widely adopted by the JavaScript community.
Supports custom scripts defined in the package.json file.
Disadvantages:
Dependency tree can become nested and lead to duplication of packages, increasing disk space usage.
Parallelism and performance could be better, especially for large projects.
Older versions of NPM had issues with security and versioning, although these have improved in recent versions.

37. Which Promise API methods do you know? What is the difference between them?
Promise.resolve(value): This method returns a Promise that is resolved with the given value. If the value is a thenable (an object with a .then() method), it will be unwrapped and resolved; otherwise, the returned Promise will be fulfilled with the value.
Promise.reject(reason): This method returns a Promise that is rejected with the given reason.
Promise.all(iterable): This method takes an iterable (such as an array or a string) of Promises and returns a new Promise that is fulfilled with an array of the resolved values from all the input Promises. However, if any of the input Promises are rejected, the returned Promise will be immediately rejected with the reason of the first rejected Promise.
Promise.race(iterable): This method takes an iterable of Promises and returns a new Promise that is settled (either fulfilled or rejected) as soon as the first Promise in the input iterable is settled. The result (either the resolved value or the rejection reason) of the settled Promise is used to settle the returned Promise.
Promise.allSettled(iterable): This method takes an iterable of Promises and returns a new Promise that is fulfilled with an array of objects representing the outcome of each Promise in the input iterable. Each object has a status property that can be either 'fulfilled' or 'rejected', and a value or reason property containing the resolved value or rejection reason.
Promise.prototype.then(onFulfilled, onRejected): This method is used to attach callbacks to a Promise that will be called when the Promise is fulfilled (resolved with a value) or rejected. You can provide two optional callback functions: onFulfilled and onRejected.
Promise.prototype.catch(onRejected): This method is used to attach a callback that will be called when the Promise is rejected. It's equivalent to calling .then(undefined, onRejected).
Promise.prototype.finally(onFinally): This method is used to attach a callback that will be called when the Promise is settled (either fulfilled or rejected). The callback is executed regardless of whether the Promise was fulfilled or rejected.

38. Provide the structure of an HTTP request/response.
Request - Request Line. Headers. Body 
Response - Status Line. Headers. Body 

39. What are new Set() and new Map()?
In JavaScript, new Set() creates a new collection of unique values, while new Map() creates a new collection of key-value pairs.

40. What are the logical operators && and ||, and how do these operators differ from the nullish coalescing operator '??'?
Logical AND (&&) operator: Returns true if both operands are truthy, otherwise returns false.
Logical OR (||) operator: Returns true if at least one of the operands is truthy, otherwise returns false.
Nullish Coalescing (??) operator: Returns the right-hand operand if the left-hand operand is null or undefined, otherwise returns the left-hand operand.
In summary:
&& returns the right-hand operand if both operands are truthy.
|| returns the right-hand operand if at least one operand is truthy.
?? returns the right-hand operand if the left-hand operand is nullish.

Database
41. What are databases used for in applications?
Databases are used to store, organize, and manage large amounts of structured data in applications, enabling efficient data retrieval, manipulation, and analysis.

42. What is ORM and what is it used for?
ORM (Object-Relational Mapping) is a programming technique that enables developers to interact with a relational database using object-oriented programming concepts. It is used to simplify and automate the conversion between data stored in a database and the objects used in an application's code.

43. What is data migration? Why is it necessary?
Data migration refers to the process of transferring data from one storage system, format, or location to another. It is necessary for various reasons, including:
Upgrading Systems: When adopting new technologies, software, or hardware, data needs to be moved from old systems to the new ones.
Consolidation: Organizations might merge or restructure, requiring data from multiple sources to be combined into a single system.
Data Center Relocation: Moving data between physical locations during a data center move.
Database Upgrades: When upgrading a database system, data must be migrated to the new version.
Platform Changes: Switching platforms (e.g., from on-premises to cloud) requires data migration to the new environment.
Performance Improvements: Data may be migrated to optimize performance, such as moving to a more efficient database system.
Data Cleansing: During migration, data can be cleaned, standardized, and transformed.
Effective data migration ensures data integrity, minimizes downtime, and maintains business continuity during transitions.

44. What is a transaction?
A transaction is a unit of work or a sequence of operations in a database that is treated as a single, indivisible entity. It represents a logical or physical change to a database and is typically composed of one or more database operations, such as inserts, updates, or deletes.
Transactions ensure data consistency and integrity by following the ACID properties:
Atomicity: A transaction is atomic, meaning it is treated as a single operation. It is either completed in its entirety or not at all. If any part of the transaction fails, the entire transaction is rolled back, and the database remains unchanged.
Consistency: A transaction takes the database from one consistent state to another. It ensures that the data conforms to predefined rules and constraints.
Isolation: Transactions are executed in isolation from each other. This ensures that concurrent transactions do not interfere with each other's intermediate states, preserving data integrity.
Durability: Once a transaction is successfully completed, its changes are permanent and are stored in the database, even in the event of system failures.
Transactions are crucial for maintaining data integrity and reliability in a multi-user, concurrent database environment. They provide a way to ensure that database operations are reliable and predictable, even in the presence of failures or concurrent access by multiple users.

45. How to update the value of a column in a table?
To update the value of a column in a table, you would typically use an SQL (Structured Query Language) statement called the UPDATE statement.

46. Using what can you filter the Users table based on age?
You can filter the Users table based on age using an SQL SELECT statement along with a WHERE clause. Here's an example of how you can do it:

WEB
46. What is Cross-Origin Resource Sharing (CORS)? Where does it occur?
Cross-Origin Resource Sharing (CORS) is a security feature implemented by web browsers to control and regulate web requests made from one domain (origin) to another. It is a mechanism that allows or restricts web pages hosted on one domain to make requests for resources (such as data or scripts) located on a different domain. CORS prevents potentially malicious websites from making unauthorized requests to other domains on behalf of the user.
CORS occurs in the context of web browser interactions when an HTTP request is made from a web page on one origin (domain) to a different origin. The browser enforces CORS by including specific headers in the HTTP requests and responses. These headers indicate whether the requested resource should be shared with the requesting origin or not, based on the policies set by the server hosting the resource. If the server's CORS policy allows the request, the browser allows the response to be accessed by the requesting web page. If the server's CORS policy restricts the request, the browser blocks access to the response data, preventing potential security vulnerabilities.

47. How to detect a CORS error in the developer console?
In the developer console of a web browser, a CORS error can be detected by observing the presence of an error message that typically includes phrases like "Cross-Origin Request Blocked" or "No 'Access-Control-Allow-Origin' header". This error message indicates that the browser has prevented a web page from making a cross-origin request due to CORS restrictions.

48. Name the main HTTP methods of RESTful or CRUD applications.
The main HTTP methods used in RESTful or CRUD (Create, Read, Update, Delete) applications are commonly referred to as CRUD operations. These methods correspond to the basic actions that can be performed on resources in a system. The main HTTP methods for CRUD operations are:
POST: Used to create a new resource on the server. It submits data to be processed to a specified resource.
GET: Used to retrieve data from the server. It requests the representation of a resource's state.
PUT: Used to update or replace an existing resource on the server. It sends data to modify the resource's state.
PATCH: Similar to PUT, but used to apply partial modifications to an existing resource. It sends data to update specific fields of the resource.
DELETE: Used to remove a resource from the server. It requests the removal of the specified resource.
These HTTP methods map directly to the CRUD operations that are commonly associated with working with data in a RESTful API. They allow clients to interact with server resources in a standardized way, making it easier to design and maintain web services.

49. What is DNS?
DNS stands for Domain Name System. It is a decentralized system that translates human-readable domain names (like www.example.com) into IP addresses, which computers use to locate and communicate with each other on the internet. In essence, DNS acts as a directory that helps browsers and other applications find the correct servers for the websites and services you want to access.

HTML + CSS
50. What are the methods of centering an element horizontally and vertically that you know?
Flexbox: Use display: flex on the parent element and justify-content: center for horizontal centering, and align-items: center for vertical centering.
CSS Grid: Apply display: grid on the parent element and use place-items: center to center both horizontally and vertically.
Absolute Positioning: Use position: absolute on the element to be centered and set top, bottom, left, and right properties to 0. Also, set margin: auto to center horizontally.
Transform: Apply position: relative on the parent, and position: absolute with top: 50% and left: 50% on the element to be centered. Then, use transform: translate(-50%, -50%) to adjust for centering.
Table Display: Utilize display: table on the parent, and display: table-cell with vertical-align: middle for vertical centering.

51. How to target all links with a ".com" in the href attribute and how to hide such links?
To target all links with a ".com" in the href attribute and hide them using CSS, you can use the following code:
a[href*=".com"] {
  display: none;
}
In this code, the a[href*=".com"] selector targets all anchor (<a>) elements with an href attribute containing ".com". The display: none; property is then applied to hide those links.

52. Can you achieve click fixation using HTML + CSS? Provide an example.
Click fixation, often referred to as "clickjacking," is a malicious technique where a user is tricked into clicking on something different from what they perceive. 

53. What is "collapsing"?
In the context of web development and CSS, "collapsing" often refers to the behavior of margins and certain layout properties. Let's explore these concepts:
Collapsing Margins:
In CSS, adjacent vertical margins of block-level elements can collapse into a single margin under certain conditions. This can happen when two or more elements are stacked vertically with margins between them. The resulting margin is usually the larger of the two margins, not their sum.
For example, if you have two paragraphs with margins, like this:
<p>Paragraph 1</p>
<p>Paragraph 2</p>
css
p {
  margin-top: 20px;
  margin-bottom: 30px;
}
The space between the paragraphs would be 30px, not the sum of 20px and 30px.
Collapsing Layout:
In some cases, elements might collapse in terms of layout. For instance, if an element's content is empty or if it only contains floated elements, it might collapse and not take up any space. This can sometimes lead to unexpected layout behavior.
It's important to understand these concepts to avoid unexpected spacing or layout issues when working with CSS and HTML. Keep in mind that the behavior of collapsing margins can be influenced by various factors, such as positioning and the presence of certain elements like borders and padding.

54. What will be the distance between these two elements:
html
Copy code
<div style="display: block">
  <div style="margin-bottom: 25px">AAA</div>
  <div style="margin-top: 21px">BBB</div>
</div>
Will the answer change if you change display: block to display: flex?
The distance between the two elements will be determined by the collapsing margins. In this case, the larger of the two margins (25px and 21px) will be used as the effective margin between the two elements. The answer will not change if you change display: block to display: flex.
Here's how the calculation works:
The first <div> has a margin-bottom of 25px.
The second <div> has a margin-top of 21px.
Since these margins are adjacent (i.e., they share a common edge), they will collapse, and the larger margin value (25px) will be used as the effective margin between the two elements.
So, the distance between the two elements will be 25px, regardless of whether you use display: block or display: flex for the parent <div>.
In the case of changing display: block to display: flex, the collapsing margin behavior remains the same, and the distance between the elements will still be determined by the larger margin value (25px). The use of display: flex on the parent element won't affect the collapsing margins between these child elements.

55. Why do developers recommend placing scripts before the closing body tag? What happens if you include JS code in the head?
Placing JavaScript (JS) scripts before the closing </body> tag is a recommended best practice for several reasons:
Faster Page Load: Browsers render content from top to bottom, and they pause rendering when they encounter a script tag. If you place scripts in the <head> section, the browser might have to download and execute the scripts before continuing to render the rest of the page. This can result in slower perceived page load times for users. By placing scripts at the end of the <body> tag, you ensure that the main content of the page loads and renders first, giving users a faster initial experience.
Progressive Rendering: Placing scripts before the closing </body> tag allows the browser to render the visible content of the page without being blocked by script execution. This approach enables progressive rendering, where users can see and interact with the content as it loads, even if some dynamic features (handled by scripts) are not yet functional.
Avoiding Blocking: Browsers generally block the rendering process when they encounter a <script> tag, especially if the script is placed in the <head> section. This can lead to a "render-blocking" effect, where the browser won't continue rendering until the script has been downloaded and executed. Placing scripts at the end of the <body> tag minimizes this effect, allowing for a smoother user experience.
Improved Page Responsiveness: If you include JavaScript code in the <head> section, the browser must download and execute that code before it starts rendering the rest of the page. This can cause the page to feel less responsive to user interactions until the scripts have completed execution. By placing scripts at the end of the <body> tag, you allow the browser to prioritize rendering the visible content first and then process the scripts afterward.

56. What is the purpose of the defer and async attributes in the script tag?
The defer and async attributes in the <script> tag control how JavaScript files are downloaded and executed in relation to the HTML parsing and rendering process:
defer: The defer attribute indicates that the script should be executed after the HTML has been fully parsed, but before the DOMContentLoaded event. It doesn't block the rendering of the page and maintains the order of script execution as they appear in the HTML. It's ideal for scripts that need to be executed in a specific order and can safely be deferred without affecting the page's functionality.
async: The async attribute indicates that the script is independent and can be downloaded and executed asynchronously. It doesn't block the rendering of the page, and the script will execute as soon as it's downloaded, potentially out of order compared to other scripts. This is useful for non-blocking scripts that don't rely on each other and can run independently.
In short, defer delays script execution until after the HTML is parsed, while async allows scripts to be downloaded and executed asynchronously without blocking the rendering process.

57. What is the tabindex attribute? Where is it used?
The tabindex attribute is used in HTML to control the order in which elements receive focus when navigating through a web page using the keyboard. It assigns a numerical value to an element, indicating its position in the keyboard navigation sequence. This helps users who rely on keyboard navigation to move efficiently between interactive elements on a webpage, such as links, form fields, and buttons. The element with a lower tabindex value will be focused first, followed by elements with higher value
