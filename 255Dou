-- https://dou.ua/lenta/articles/interview-node-js/?from=comment-digest_post&utm_source=digest-comments&utm_medium=email&utm_campaign=31072023

ðŸ’¡ Junior
Node.js

1. What is Node.js?
Node.js is an open-source, server-side JavaScript runtime environment that allows developers to execute JavaScript code outside of a web browser. 

2. What are the main advantages and disadvantages of using Node.js?
- Advantages of using Node.js:
Speed and efficiency: Node.js is built on the V8 JavaScript engine, which provides high performance and executes code quickly, leading to faster application development and improved server response times.
Non-blocking, event-driven architecture: Node.js uses an event loop that allows asynchronous I/O operations, making it efficient in handling concurrent connections and scalable for real-time applications.
Single language throughout the stack: JavaScript can be used both on the client-side and server-side, allowing developers to work with the same language and share code between the front-end and back-end, 
reducing the need for context switching.
Large and active community: Node.js has a vast and active community of developers, which means extensive support, numerous libraries, and frequent updates, making it easier to find solutions 
to problems and access a wide range of modules.
Package manager (npm): Node.js comes with npm (Node Package Manager), a powerful tool that enables easy installation, management, and sharing of packages and modules, enhancing code reusability.
- Disadvantages of using Node.js:
Not suitable for CPU-intensive tasks: Node.js is designed to excel in I/O-intensive applications, but it may not be the best choice for CPU-intensive tasks due to its single-threaded nature.
Callback-heavy code: Asynchronous programming in Node.js relies on callbacks, which can lead to complex and nested code structures (known as "callback hell") if not managed properly.
Immaturity in some areas: While Node.js has grown rapidly, certain areas of the ecosystem may still be less mature or lack adequate documentation and community support.
Lack of multi-core utilization by default: Node.js runs on a single thread, which means it doesn't natively utilize multiple CPU cores. Developers need to implement additional strategies (e.g., clustering) 
to leverage multi-core systems effectively.
Security concerns: Being open-source and widely used, Node.js may become a target for security vulnerabilities. Careful attention should be given to keep dependencies updated and adopt security best practices.

3. For which tasks is Node.js not suitable?
There are certain tasks for which Node.js might not be the most suitable choice:
- CPU-Intensive Tasks: Node.js is built on the V8 JavaScript engine, which is excellent for handling I/O operations and asynchronous tasks but not well-suited for CPU-intensive computations. 
If your application requires heavy computational tasks, such as complex data processing, image manipulation, or video encoding, using Node.js might not be the most efficient option. 
In such cases, a language like Python, Go, or C++ might be more suitable.
- Memory-Intensive Applications: While Node.js performs well with many concurrent connections, it may not be the best choice for applications that require a significant amount of memory.
If your application involves heavy in-memory data processing or caching large datasets, other languages like Java or C++ with more memory management control might be more appropriate.
- High-Throughput Synchronous Operations: Node.js is inherently single-threaded, and synchronous operations can block the event loop, leading to performance bottlenecks. 
In scenarios where an application heavily relies on synchronous I/O operations, other languages like Go or Java with multithreading or asynchronous capabilities may be more suitable.
- Real-Time Data Manipulation: Node.js is excellent at handling real-time web applications using technologies like WebSockets. However, for applications that require low-level data manipulation or hardware interaction, 
languages like C or C++ might be more suitable due to their performance and direct access to hardware.
- Complex Multi-Threaded Applications: Node.js, being single-threaded, might not be the best choice for developing complex multi-threaded applications that require extensive parallelism
and low-level control over threads. In such cases, languages like Java or Go, with strong support for multi-threading, are better options.
- Enterprise-level ETL (Extract, Transform, Load) Processes: While Node.js can handle ETL processes for smaller projects, for large-scale, complex enterprise-level 
ETL tasks that involve significant data processing and transformation, specialized ETL tools like Apache Spark or Apache NiFi might be more appropriate.
- Resource-Intensive Background Jobs: For resource-intensive, long-running background jobs, using a task-specific tool or language like Celery (Python), Sidekiq (Ruby), or Apache Kafka might be more suitable.
In conclusion, Node.js might not be the best choice for tasks that are CPU-intensive, memory-intensive, require high-throughput synchronous operations, involve complex multi-threading, or necessitate low-level hardware interactions.

4. What are the main components of Node.js?
- V8 Engine: Node.js is built on the Google V8 JavaScript engine, which is also used in the Chrome web browser. V8 compiles JavaScript code into machine code, making it much faster than traditional interpreters.
- Libuv: Libuv is a multi-platform, asynchronous I/O (Input/Output) library that provides the foundation for Node.js' non-blocking, event-driven architecture. It handles tasks like networking, file system operations, and timers.
- Core Modules. NPM 
- Event Loop: Node.js follows an event-driven, non-blocking I/O model, and the event loop is at the core of this approach. 
It continuously checks for pending events and executes their corresponding callbacks, making Node.js highly efficient and scalable for handling concurrent connections.


5. How does Node.js server handle multiple concurrent client requests with only one thread?
- Event Loop:
Node.js relies on an event loop to manage its asynchronous operations. The event loop is a single thread that continuously checks for pending events, executes callbacks, and delegates I/O operations to the system's underlying kernel asynchronously.
- Non-Blocking I/O:
When Node.js performs I/O operations, such as reading from a file, making an HTTP request, or querying a database, it does so in a non-blocking manner. Instead of waiting for the operation to complete, Node.js immediately moves on to execute other code, allowing it to handle other client requests while waiting for the I/O operation to finish.
- Callbacks and Event-Driven Programming:
Node.js uses callbacks to handle the results of asynchronous operations. When an asynchronous operation completes, it triggers a callback function, which is then executed by the event loop. This allows Node.js to process multiple client requests simultaneously without blocking the execution of other code.
- Single Thread, Multi-Threaded I/O:
While the JavaScript code in Node.js is executed in a single thread, the underlying I/O operations are handled by the operating system's multi-threaded I/O capabilities. Node.js leverages this by delegating I/O tasks to the operating system's kernel and handling the responses asynchronously when they are ready.
- Concurrency through Event Loop:
Since Node.js can handle many I/O operations simultaneously, it can efficiently manage multiple concurrent client requests. As each request's I/O operation is delegated to the event loop, Node.js can move on to process other requests without waiting for the I/O to complete.
- Avoiding CPU-Intensive Tasks:
While Node.js excels at handling I/O-bound tasks and concurrent client requests, it is not well-suited for CPU-intensive tasks that consume the event loop for extended periods. In such cases, the event loop may become blocked, and other client requests may be delayed. To handle CPU-bound tasks efficiently, developers often use techniques like offloading the processing to worker threads or using external services.


6. Is it possible to use multiple threads in Node.js? Which modules are used for this purpose?
Yes, it is possible to use multiple threads in Node.js to perform CPU-intensive tasks more efficiently and avoid blocking the event loop. Node.js provides support for creating and managing multiple threads through the "Worker Threads" module, which was introduced in Node.js version 10.5.0 and is stable from version 12 onward.
The "Worker Threads" module allows you to create and communicate with additional threads that run in parallel to the main Node.js process. These worker threads can execute CPU-intensive tasks independently, freeing up the main thread to continue processing other tasks, such as handling incoming client requests.

7. Does Node.js interpret or compile program code?
Node.js uses a combination of interpretation and compilation to execute program code.
Interpretation:
Node.js is an interpreter for JavaScript code. When you run a Node.js application, the JavaScript code is read line by line, and the Node.js runtime interprets each line of code and executes it immediately. This interpretation happens at runtime, which means the code is executed on-the-fly without any pre-processing.
Just-in-Time (JIT) Compilation:
Node.js also employs Just-in-Time (JIT) compilation to optimize the performance of JavaScript execution. As the code is being interpreted and executed, the Node.js engine analyzes the code and identifies hotspotsâ€”sections of code that are executed frequently. It then compiles those hotspots into optimized machine code.
- So, the flow of execution in a Node.js application generally involves the following steps:
The Node.js runtime interprets the JavaScript code line by line.
As hotspots are identified, the V8 engine performs JIT compilation to convert those sections into optimized machine code.
The optimized machine code is executed, resulting in faster performance for frequently executed parts of the code.

8. How to read large files using Node.js?
To handle large files, you should use asynchronous methods and read the file in smaller chunks rather than loading the entire file into memory.
- Choose the Asynchronous Approach:
Using asynchronous file operations is crucial for handling large files. Asynchronous methods ensure that your Node.js application doesn't block while reading the file and can continue processing other tasks.
- Use Streams:
Node.js provides built-in support for streams, which are a mechanism for reading and writing data in chunks. Streams are particularly useful for handling large files as they read data incrementally without loading the entire file into memory.
- Create a Readable Stream:
To read a file using streams, you need to create a readable stream. You can use the fs.createReadStream() method to achieve this. The createReadStream() method allows you to specify the file path and options such as encoding, highWaterMark (the size of each chunk), etc.
- Handle Stream Events:
Once you have a readable stream, you can listen for specific events to handle the data. The essential events to handle are data, which is triggered when new data chunks are available, and end, which is triggered when the entire file has been read.
- Process Data in Chunks:
As the data event is triggered, you'll receive chunks of data. Process the data as needed in each event callback to avoid loading the entire file into memory at once.

9. What are libuv and v8? What are their purposes?
libuv:
libuv is a cross-platform, asynchronous I/O library that provides the event loop, which is the foundation for Node.js' non-blocking, event-driven architecture. It abstracts the operating system's underlying I/O capabilities and provides a consistent API for handling events, timers, network operations, and file system operations.
Purposes of libuv - Event Loop, Asynchronous I/O, Cross-Platform Support, Timers and Event Handling
V8:
V8 is an open-source JavaScript engine developed by Google. It is written in C++ and is the heart of Google Chrome's JavaScript execution. Node.js leverages V8 as its JavaScript runtime, allowing it to execute JavaScript code efficiently and with high performance.
Purposes of V8: JavaScript Execution, Memory Management, Cross-Platform Support, ECMAScript Compliance

10. What is the difference between microtasks and macrotasks? Provide examples of such tasks.
Microtasks and macrotasks are two types of tasks that are managed by the event loop in JavaScript environments, including Node.js and web browsers.
Microtasks are tasks with higher priority than macrotasks. Microtasks are tasks with higher priority than macrotasks. Microtasks are tasks with higher priority than macrotasks. 
When the event loop checks for pending tasks, it first processes all microtasks before moving on to macrotasks. Microtasks are typically used for tasks that need to be executed immediately after the current script finishes, but before the next rendering or I/O event. They allow developers to control the order of execution more precisely.
Promise callbacks. process.nextTick(). Mutation Observer
Macrotasks, also known as "tasks" or "callbacks," have lower priority than microtasks. They are added to the macrotask queue, and the event loop processes them after all pending microtasks have been executed. Macrotasks are usually I/O-bound or timer-based operations.
I/O operations: Reading from or writing to files or sockets.
Timers: setTimeout, setInterval, and setImmediate.
Network requests: Fetching data from a remote server using HTTP requests.
DOM rendering: Handling updates to the DOM and user interface.
The order of execution for tasks in the event loop is as follows:
Execute all pending microtasks (Process all microtasks in the microtask queue).
Execute one macrotask (Dequeue and execute a task from the macrotask queue).
If there are more microtasks, go back to step 1. Otherwise, continue to the next macrotask (if any).

11. What is a stream?
A stream is a fundamental concept in Node.js used for handling data efficiently, especially when dealing with large amounts of data or data that arrives or needs to be processed incrementally. Streams provide an abstraction to read or write data in chunks, allowing for lower memory usage and faster processing, as data is processed as soon as it becomes available, instead of waiting for the entire data set to be loaded.

12. What types of streams do you know?
Readable Stream:
A readable stream represents a source of data from which you can read data chunk by chunk. Examples of readable streams include reading from files, making HTTP requests, and processing incoming network connections. Readable streams emit events like 'data', 'end', and 'error' to handle the data as it arrives or encounters an error.
Writable Stream:
A writable stream represents a destination where you can write data chunk by chunk. Examples of writable streams include writing to files or making HTTP responses. Writable streams can be used to handle incoming data and store it or send it to another location.
Streams can also be Transform Streams, which are both readable and writable.

13. What is the event loop? What are its components, and how does it work?
The event loop is a crucial part of Node.js (and other JavaScript environments) that enables non-blocking, asynchronous behavior, making it efficient for handling I/O-bound operations and concurrent tasks. 
The event loop is responsible for managing the execution of callbacks and events in a continuous loop, ensuring that code runs efficiently without blocking the main thread.
Components of the Event Loop:
Call Stack:
The call stack is a stack data structure that keeps track of function calls in the current execution context. When a function is called, it is pushed onto the stack, and when the function returns, it is popped off the stack. The call stack handles the synchronous execution of code.
Callback Queue (Task Queue):
The callback queue is a queue that stores asynchronous callbacks, such as those from I/O operations (e.g., reading from a file, making an HTTP request) or timers (e.g., setTimeout, setInterval). When an asynchronous operation is completed, its callback is placed in the callback queue.
Microtask Queue (Job Queue):
The microtask queue is another queue that stores microtasks. Microtasks are used to handle higher-priority tasks that need to be executed immediately after the current operation but before the event loop continues to process other callbacks. Microtasks are typically used for Promise callbacks and other high-priority tasks.
How the Event Loop Works:
The event loop runs continuously, checking for tasks in the following order:
Check for Microtasks:
Before executing any macrotask (e.g., I/O callback, timer callback), the event loop checks if there are any pending microtasks in the microtask queue. If there are, it executes all microtasks in sequence until the microtask queue is empty.
Execute Macrotasks (Callback Queue):
If there are no microtasks or after all microtasks have been executed, the event loop dequeues and executes one macrotask (callback) from the callback queue. This task can be an I/O operation completion callback or a timer callback, among others.
Perform Rendering (Optional, in the Browser):
In web browsers, the event loop might include a rendering step, where the browser renders changes to the DOM. This step is omitted in Node.js, which does not handle rendering.
Repeat:
After executing a macrotask, the event loop starts again by checking for microtasks, executing macrotasks, and so on, in a continuous loop.

14. What is logging and monitoring?
Logging is the process of recording information about events, actions, and errors that occur within your Node.js application. Logs are essential for debugging and troubleshooting issues in production environments. Commonly, logs are written to files or sent to centralized logging services, where they can be easily analyzed.
Monitoring involves the continuous observation of various metrics and performance indicators of your Node.js application during runtime. It helps identify potential bottlenecks, performance issues, and anomalies that may arise in the system. Monitoring allows you to maintain the health and stability of your application by keeping track of various aspects, including:

15. What is the difference between a monolith and a microservice?
A monolith and a microservice are two different architectural styles used in software development to design and build applications.
A monolithic architecture refers to an application that is built as a single, large, and interconnected unit. In a monolith, all components, modules, and functionalities of the application are tightly coupled and run as a single process. This means that the entire application is deployed as one unit, and any changes or updates to a specific part of the application require redeploying the entire monolith.
Advantages of Monolith:
Simplicity: Developing and deploying a monolith can be simpler and easier compared to a microservices architecture.
Performance: Monoliths can be more efficient in terms of resource usage because there is less overhead in communication between components.
Disadvantages of Monolith:
Scalability: It can be challenging to scale different components independently in a monolith, limiting the ability to handle high loads.
Maintenance: As the application grows, maintaining and evolving a monolith can become complex and challenging.
Continuous Deployment: Making frequent updates to a monolithic application can lead to downtimes during the deployment process.
Microservices:
Microservices, on the other hand, is an architectural style where an application is divided into a set of loosely coupled and independently deployable services. Each service represents a specific business capability and can be developed, deployed, and scaled independently. These services communicate with each other through APIs, allowing them to work together as part of a larger system.
Advantages of Microservices:
Scalability: Microservices allow you to scale specific services independently, making it easier to handle varying loads on different parts of the application.
Flexibility: Since each microservice is a separate unit, developers can use different technologies, programming languages, and databases that suit the specific requirements of each service.
Continuous Deployment: Microservices promote continuous deployment practices, enabling faster updates and reducing the risk of downtime during updates.
Disadvantages of Microservices:
Complexity: The distributed nature of microservices adds complexity to the system, which can lead to challenges in monitoring, testing, and debugging.
Overhead: Communication between microservices can introduce additional overhead compared to the more streamlined communication in monoliths.
Development Effort: Building and managing microservices requires additional effort in terms of design, deployment, and coordination.

16. What is the difference between language keywords like 'string' and 'String'?
'string':
In JavaScript, 'string' is not a keyword; it is a primitive data type.
'String':
In JavaScript, 'String' is a built-in constructor function for strings. Unlike the 'string' data type, 'String' is an object wrapper for strings. You can use 'String' to create instances of string objects. For example:
javascript
const myStringObj = new String("Hello, world!");



Express.js

17. What is the purpose of using middleware?
Middleware in Express is a fundamental concept that allows you to add modular functionalities and processing steps to your web application's request-response cycle. It acts as a bridge between the incoming HTTP request and the final HTTP response, allowing you to perform various tasks, modifications, or validations before the request reaches its final destination (route handler) or after the response has been generated.

18. How to transition from one middleware to another?
In Express, middleware functions are executed in the order they are defined in the code. When you call the next() function inside a middleware, it passes control to the next middleware function in the chain. This allows you to transition from one middleware to another.

19. How to prioritize middleware?
In Express, the order in which you define middleware determines their priority. Middleware functions are executed in the order they are added using the app.use() or router.use() methods. The earlier a middleware is defined, the higher its priority.

20. How to organize an error handler?
Organizing an error handler in Express involves creating a dedicated middleware function to handle errors that occur during the request-response cycle. This helps you centralize error handling logic and provide consistent error responses to clients. 
1. Create the Error Handler Middleware
2. Error Response Structure
3. Throwing Errors
4. Async Error Handling 

JavaScript

21. What is asynchronous behavior and asynchronous code?
In JavaScript, asynchronous behavior refers to the ability of the language to execute code in a non-blocking manner. Asynchronous code allows you to perform tasks without waiting for previous tasks to complete, which is particularly important for handling operations that might take some time to finish, such as network requests, file I/O, or other time-consuming operations.

22. What is the difference between var, let, and const? Why should const be used if the variable will not be changed later in the code?
In JavaScript, var, let, and const are used to declare variables, but they have different scopes and behaviors. Here's a breakdown of the differences:
- var: Variables declared with var are function-scoped or globally-scoped, depending on whether they are declared inside a function or outside of any function. They are also hoisted to the top of their scope, which means they are moved to the top of their containing function or script before execution.
- let: Variables declared with let are block-scoped, which means they are confined to the block (enclosed by curly braces) in which they are declared. They are not hoisted to the top of the block and are not accessible before the declaration.
- const: Like let, variables declared with const are block-scoped and not hoisted. The key difference is that variables declared with const must be assigned a value when declared, and once assigned, their value cannot be changed. They are constants.
In summary, use var when you need function or global scope (although let and const are generally preferable), use let when you need block scope and intend to reassign the variable, and use const when you need block scope and want to ensure the variable's value remains unchanged.

23. How can you delay the execution of a function to a specific time?
In JavaScript, you can delay the execution of a function to a specific time using two main methods: setTimeout and setInterval

24. How can you delay the execution of a function to a specific time?
To delay the execution of a function to a specific time, you can use the setTimeout function in JavaScript. setTimeout allows you to schedule the execution of a function after a certain delay in milliseconds.

25. What methods of declaring a function do you know?
Function Declaration. Function Expression. Arrow Function Expression. Method Shorthand. Function Constructor. Immediately Invoked Function Expression. Async Function Declaration

26. What is an anonymous function?
An anonymous function is a function that does not have a name. In programming, functions are typically defined with a name that can be used to call or reference the function later. However, in some cases, you might want to create a function without giving it a name. Such functions are called "anonymous functions."

27. Provide examples of self-invoking functions.
(function() {
  console.log("This is a self-invoking function!");
})();

28. What is the difference between function expression and function declaration?
Hoisting:
Function Declarations are hoisted in JavaScript, which means they are moved to the top of their containing scope during the compilation phase. This allows you to call a function before its actual declaration in the code.
Function Expressions, on the other hand, are not hoisted in the same way. The variable containing the function is hoisted, but the assignment of the function to the variable remains where it is in the code.
Syntax

29. How can you create a new array in JavaScript containing only numbers greater than 10 from an existing array of numbers? Which array method would you use for this?
const existingArray = [5, 12, 8, 15, 20, 3, 18];
const newArray = existingArray.filter(number => number > 10);

30. How can you delete an element from an array and an object?
Deleting an Element from an Array:
Using splice() method. Using filter() method (creates a new array without the element). 
Deleting a Property from an Object delete myObject[keyToDelete];

31. What is the purpose of the void type?
In JavaScript, the void keyword is used to evaluate an expression and then return the undefined value. It doesn't serve a particularly functional purpose in the sense of producing a useful value, but it can be used in a couple of scenarios:

32. Where and why do you use super()?
In object-oriented programming languages like JavaScript, the super() keyword is used to call the constructor of a parent class. It is used within the constructor of a subclass to invoke the constructor of its parent class. This is typically done when you want to initialize properties or perform setup logic that is common to both the subclass and the parent class.

33. What is the purpose of 'this' keyword and in what scenarios is it used?
The this keyword in JavaScript is a special keyword that refers to the current context or object. Its behavior can change depending on how and where it is used. The primary purpose of the this keyword is to refer to the object that the currently executing code belongs to. 

34. What is NaN and how can you use it?
NaN stands for "Not-a-Number," and it is a special value in JavaScript used to represent the result of an invalid or undefined mathematical operation. In other words, when a mathematical operation or function is expected to return a number, but it fails to do so, the result is NaN.

35. What is NPM? What alternatives do you know?
NPM (Node Package Manager) is a package manager for JavaScript programming language. It is primarily used for managing and distributing packages (libraries, modules, and tools) that you can use to build JavaScript applications, both on the frontend and the backend. NPM is tightly integrated with Node.js, a runtime environment that allows you to execute JavaScript code outside of a web browser.
Yarn. pnpm. Bower

36. What are the advantages and disadvantages of NPM compared to Yarn/PNPM?
NPM (Node Package Manager):
Advantages:
Comes bundled with Node.js, so no additional installation is needed.
Large and mature package registry with a wide selection of packages.
Well-documented and widely adopted by the JavaScript community.
Supports custom scripts defined in the package.json file.
Disadvantages:
Dependency tree can become nested and lead to duplication of packages, increasing disk space usage.
Parallelism and performance could be better, especially for large projects.
Older versions of NPM had issues with security and versioning, although these have improved in recent versions.

37. Which Promise API methods do you know? What is the difference between them?
Promise.resolve(value): This method returns a Promise that is resolved with the given value. If the value is a thenable (an object with a .then() method), it will be unwrapped and resolved; otherwise, the returned Promise will be fulfilled with the value.
Promise.reject(reason): This method returns a Promise that is rejected with the given reason.
Promise.all(iterable): This method takes an iterable (such as an array or a string) of Promises and returns a new Promise that is fulfilled with an array of the resolved values from all the input Promises. However, if any of the input Promises are rejected, the returned Promise will be immediately rejected with the reason of the first rejected Promise.
Promise.race(iterable): This method takes an iterable of Promises and returns a new Promise that is settled (either fulfilled or rejected) as soon as the first Promise in the input iterable is settled. The result (either the resolved value or the rejection reason) of the settled Promise is used to settle the returned Promise.
Promise.allSettled(iterable): This method takes an iterable of Promises and returns a new Promise that is fulfilled with an array of objects representing the outcome of each Promise in the input iterable. Each object has a status property that can be either 'fulfilled' or 'rejected', and a value or reason property containing the resolved value or rejection reason.
Promise.prototype.then(onFulfilled, onRejected): This method is used to attach callbacks to a Promise that will be called when the Promise is fulfilled (resolved with a value) or rejected. You can provide two optional callback functions: onFulfilled and onRejected.
Promise.prototype.catch(onRejected): This method is used to attach a callback that will be called when the Promise is rejected. It's equivalent to calling .then(undefined, onRejected).
Promise.prototype.finally(onFinally): This method is used to attach a callback that will be called when the Promise is settled (either fulfilled or rejected). The callback is executed regardless of whether the Promise was fulfilled or rejected.

38. Provide the structure of an HTTP request/response.
Request - Request Line. Headers. Body 
Response - Status Line. Headers. Body 

39. What are new Set() and new Map()?
In JavaScript, new Set() creates a new collection of unique values, while new Map() creates a new collection of key-value pairs.

40. What are the logical operators && and ||, and how do these operators differ from the nullish coalescing operator '??'?
Logical AND (&&) operator: Returns true if both operands are truthy, otherwise returns false.
Logical OR (||) operator: Returns true if at least one of the operands is truthy, otherwise returns false.
Nullish Coalescing (??) operator: Returns the right-hand operand if the left-hand operand is null or undefined, otherwise returns the left-hand operand.
In summary:
&& returns the right-hand operand if both operands are truthy.
|| returns the right-hand operand if at least one operand is truthy.
?? returns the right-hand operand if the left-hand operand is nullish.
